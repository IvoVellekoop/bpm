classdef VCAO
    %% VCAO was used to simulate the idea of volume-conjugated adaptive optics.
    % In this procedure, the forward direction means from back focal plane
    % to lens to scattering medium, and the reverse direction is the other
    % way.
    % The procedure is executed as following:  
    % 1) The system parameters was defined mostly in VCAO(...) and the
    % scattering medium is generated by CreateMedium(...)
    % 2) Need a pattern on the back focal plane of the objective, such as
    % a spiral pattern. The position of each point in the spiral pattern
    % will be calculated by CalcCoM(...) and stored
    % 3) Each point in the spiral pattern will be propagated in the 
    % scattering medium individually in GetScattered(), and Fourier
    % transformed to what it should be in the back focal plane again, which
    % is the output.
    % 4) The SumField() will added the output of all spiral points into a
    % summed field as a new input.
    % 5) revPropagate() will propagate the field in the backfocal plane by
    % first: inverse fourier transformed the field, and second: propagate
    % in vaccum back to the position of the front surface of the scattering 
    % medium, and third: propagate in the forward direction through the
    % medium.
    % 6) StepPhaseScanning() performs the step-phase scanning on the summed
    % field created by step 4).
    % 7) GradPhaseScanning() put a phase gradient instead of phase step on
    % top of the summed field in step 4) to check the memory effect.
    properties        
        lambda; % um
        pixel_size; %um
        field_size; %um
        layer_thick; % Thickness of every section in Z (µm)
        Scat_Layer_No; % Layer number of the scattering medium
        scattering_coefficient = 5; % Here and the next row defines how scatter the scattering medium is. 
        GaussFilterSigma = 4;
        DimSize; % number of pixels in one dimension
        medium; % the scattering medium
        CofM; % Centers of Mass of all points in the spiral pattern
        OriSpiral; %The sum shaped fields from all points of the spiral
        ltr; %mean transport length
    end
    properties (Access=protected)
        focal_length = 10000; % of the lens, not used now
        unit;
    end
    
    methods 
        function obj = VCAO(field_size,lambda,unit)          
            obj.lambda = lambda;
            obj.unit = unit;
            obj.layer_thick = lambda/2;
            pixel_size = lambda*sqrt(2);           
            obj.pixel_size = pixel_size;
            DimSize = floor(field_size/pixel_size);
            i=0;
            while(DimSize>2)
                DimSize=DimSize/2;
                i=i+1;
            end
            obj.DimSize = 2^i;
            obj.field_size = DimSize*pixel_size;
        end
        
        function obj = CreateMedium(obj,Scat_Layer_No,scat,anisotrop)
            % creating scattering medium in a form of the random number
            % generator function.
            obj.Scat_Layer_No = Scat_Layer_No;
            obj.GaussFilterSigma = anisotrop;
            obj.scattering_coefficient = scat;
            E = Field.plane(obj.field_size,[obj.DimSize obj.DimSize],obj.lambda,'um');
            SN = E.gen_medium(Scat_Layer_No);
            SN.scat_coef = scat;
            SN.anisotropy_f = anisotrop;
            obj.medium = SN;
        end
        
        function obj=CalcCoM(obj,SpiralROI,Spiral)
        % This function is used to calculate the center of mass of each
        % point on the spiral pattern, and scale them to the current field
        % size. The spiral pattern SpiralROI and Spiral are prerequisite in
        % this function. For different patterns, a new function is needed.
            s=fieldnames(SpiralROI);
            CenterOfMass=zeros(88,2);
            threshold = 0.015;
            q = 1;
            for i=1:size(s,1)
                if rem(i,12)==1
                else
                % Calculate the position of each spiral unit by a 1024x1024 spiral
                % patterns.
        %       p=strcat('F_',num2str(i));
                    temp=Spiral.*double(getfield(SpiralROI,s{i}));
                    Sx=0; Sy=0; n=0;
                    for ip=1:size(temp,1)
                        for jp=1:size(temp,2)
                            if temp(ip,jp)> threshold
                                temp(ip,jp)=1;
                                Sx = Sx+ip;
                                Sy = Sy+jp;
                                n = n+1;
                            else
                                temp(ip,jp)=0;
                            end
                        end
                    end
                    Sx=round(Sx*(1/n));
                    Sy=round(Sy*(1/n));
                    % Scale the position of each spiral unit to the position to the
                    % current field size
                    Sx=round((Sx-511.5)*(obj.DimSize/1024)+(obj.DimSize-1)/2);
                    Sy=round((Sy-511.5)*(obj.DimSize/1024)+(obj.DimSize-1)/2);
                    CenterOfMass(q,1)=Sx;
                    CenterOfMass(q,2)=Sy;
                    q = q+1;
                    obj.CofM = CenterOfMass;
                end
            end
        end   
        
        function  Shaped_Field=GetScattered(obj,SpotSize)
        %% Each position recorded in the obj.CofM (position of foci on the
        % back focal plane) will be assinged to a gaussian PSF according to
        % the SpotSize specified. Then these points are Fourier transformed 
        % to be plane waves on the front focal plane one by one. The plane 
        % wave is then reverse propagated through the scattering medium,
        % and forward propagated through the vaccum. The output will then
        % be Fourior transformed to the field appeared in the front focal
        % plane.
            Shaped_Field = struct;
            TotalThick = obj.layer_thick*obj.Scat_Layer_No;

            for i=1:size(obj.CofM,1)
                disp(i)
                p=strcat('F_',num2str(i));
                x = [0:obj.DimSize-1];
                temp = exp(-(((x-obj.CofM(i,1)).^2)+((x'-obj.CofM(i,2)).^2))/(SpotSize)^2);
                temp=conj(temp);
    
                Erev_in= Field(temp, obj.pixel_size, obj.lambda, 'um');

                Erev_in.gpu_enabled = true;
                tic()
                Erev_out = Erev_in.propagate(obj.medium,TotalThick,-1);
        
                Edata = Erev_out.data(:,:,1);

                Erev_conj=conj(Edata);   
                Eft_in = Field(Erev_conj,obj.pixel_size, obj.lambda, 'um');
                Eft_in.gpu_enabled = true;
   
                Eft_in.gpu_enabled = true;
                Eft_in = Eft_in.propagate(ones(size(Eft_in,1),size(Eft_in,2),obj.Scat_Layer_No),TotalThick,0);

    
                Eshaped_in = Eft_in.data;
                Eshaped_in = fft2(Eshaped_in);

                Shaped_Field = setfield(Shaped_Field,p,Eshaped_in);

                toc()
            end    
        end
        
        function obj=SumField(obj,structure)
        %% This function summing all the fields saved in the structure    
            if ~isstruct(structure)
                error('input needs to be a structure')
            end
            s=fieldnames(structure);
            temp = getfield(structure,s{1});
            w=zeros(size(temp,1),size(temp,2));    
            for i=1:size(fieldnames(structure))    
                temp=getfield(structure,s{i});
                if isobject(temp)
                    temp=temp.data;
                end
            w = w+temp;
            end
            w = Field(w,obj.pixel_size, obj.lambda, obj.unit);
            obj.OriSpiral = w;
        end 
        
        
    
        function Eout=revPropagate(obj,Ein)
        %% This function performs reverse propagation. The input field 
        %  should be the field in the front focal plane. It will then be
        %  Fourier-transformed to be the field in the backfocal plane, the
        %  propagated in the reverse direction throught the vaccum and
        %  then forward-propagated through the medium. WARNING: the line
        %  195 is ifft2, but not fft2. It is originally designed for the
        %  field generated from GetScattered(). If a naive field is
        %  required to propagate by this function, the ifft2 should be 
        %  replaced by fft2.
            if isobject(Ein)
                data = Ein.data;
            else
                data = Ein;
            end
            data=ifft2(data);
            data=conj(data);
    
            data = Field(data,obj.pixel_size,obj.lambda,obj.unit);
        %   for j = 1:Scat_Layer_No
            data.gpu_enabled = true;
            Erev_in = data.propagate(ones(size(Ein,1),size(Ein,2),obj.Scat_Layer_No),obj.layer_thick*obj.Scat_Layer_No,-1);
        %   end   
            Erev_in = conj(Erev_in.data);
            Erev_in = Field(Erev_in,obj.pixel_size,obj.lambda,'um');
            Erev_in.gpu_enabled = true;
            Eout = Erev_in.propagate(obj.medium,obj.Scat_Layer_No*obj.layer_thick,0);
        end
        
        function [Escan,EscanIn] = StepPhaseScanning(obj,MaxXw,MaxYw,Shaped_Field)
        %% This function performs step phase scannig base on the field
        % stored in obj.OriSpiral. The center of mass stored in obj.CofM is
        % required to impose phase differences on differenct foci. MaxXw
        % and MaxYw specify the maximum phase differences in X and Y
        % dimensions, and the unit is wave. The step size is 5 waves (see
        % line 232 233).
            count = 1;
            TotalThick = obj.layer_thick*obj.Scat_Layer_No;
            for i=1:44
                CenterOfMass(i,:) = obj.CofM(i+44,:);
            end
            for i=45:58
                CenterOfMass(i,:) = obj.CofM(i-44,:);
            end           
            dim = ((MaxXw*2/5)+1)*((MaxYw*2/5)+1);
            Escan = zeros(obj.DimSize,obj.DimSize,dim);
            EscanIn = zeros(obj.DimSize,obj.DimSize,dim);
    
            for wavenX = MaxYw:-5:-MaxYw
                for wavenY = -MaxXw:5:MaxXw
                    tic()
                    Ephase_field = obj.genPhaseStep(wavenX,wavenY,Shaped_Field,CenterOfMass);
                    %Ephase_field = Ephase_field.data.*BigMask;
                    %Ephase_field = Field(Ephase_field.data,obj.pixel_size, obj.lambda, obj.unit);
                    %Eout_scanned = Ephase_field.propagate(obj.medium,size(Nscat,3)*obj.layer_thick);
                    Eout_scanned = obj.revPropagate(Ephase_field.data);
                    EscanIn(:,:,count) = Ephase_field.data;
                    Escan(:,:,count) = Eout_scanned.data;
                    toc()
                    count=count+1;
                end
            end
    
            Escan = SizedArray(Escan, [obj.pixel_size,obj.pixel_size, obj.layer_thick], obj.unit);
            EscanIn = SizedArray(EscanIn, [obj.pixel_size,obj.pixel_size, obj.layer_thick], obj.unit);
        end
        
        function Ephase_field = genPhaseStep(obj,wavenX,wavenY,Shaped_Field,CoM)
            % waven: number of waves
            
            %     if size(fieldnames(Shaped_Field),1) ~ size(fieldnames(Mask_Field),1);
            %         size(fieldnames(Shaped_Field),1)
            %         size(fieldnames(Mask_Field),1)
            %         error('The number of mask is not identical with the number of Field')
            %     end
            MX = max(CoM(:,1));
            mX = min(CoM(:,1));
            
            MY = max(CoM(:,2));
            mY = min(CoM(:,2));
            
%            num = size(fieldnames(Mask_Field),1);
%             if ~isstruct(Shaped_Field)
%                 error('Shaped_Field needs to be a struct');
%             end
            s = fieldnames(Shaped_Field);
%             m = fieldnames(Mask_Field);
            
            
            w = getfield(Shaped_Field,s{1});
            Ephase_field=zeros(size(w,1),size(w,2));
            
            slopeX=wavenX/(MX-mX);
            slopeY=wavenY/(MY-mY);
            
            for i=1:size(CoM,1)
                phaseX = (-(wavenX/2)+slopeX*(CoM(i,1)-mX))*2*pi;
                phaseY = (-(wavenY/2)+slopeY*(CoM(i,2)-mY))*2*pi;
                phase = phaseX+phaseY;
                
                w = getfield(Shaped_Field,s{i});
 %               Mask = getfield(Mask_Field,m{i});
                if isobject(w)
                    w = w.data*exp(1i*phase);
                else
                    w = w*exp(1i*phase);
                end
 %               Ephase_field = Ephase_field+ w.*Mask ;
                Ephase_field = Ephase_field+w;
            end
            Ephase_field = Field(Ephase_field,obj.pixel_size, obj.lambda, obj.unit);           
        end
   
        function [Escan,EscanInT] = GradPhaseScanning(obj,MaxXw,MaxYw)
            count = 1;
            dim = ((MaxXw*2/5)+1)*((MaxYw*2/5)+1)
            Escan = zeros(obj.DimSize,obj.DimSize,dim);
            EscanInT = zeros(obj.DimSize,obj.DimSize,dim);
            for wavenX = MaxXw:-5:-MaxXw
                for wavenY = -MaxYw:5:MaxYw
                    phaseX = linspace(-2*pi*wavenX/2,2*pi*wavenX/2,obj.DimSize);
                    phaseX = phaseX'.*ones(obj.DimSize,1);
                    phaseY = linspace(-2*pi*wavenY/2,2*pi*wavenY/2,obj.DimSize);
                    phaseY = ones(obj.DimSize,1)'.*phaseY;
                    Etilt = exp(1i*(phaseX+phaseY));
                    
                    EtiltIn=Etilt.*obj.OriSpiral.data;
                    %Ephase_field = Ephase_field.data.*BigMask;
                    %EtiltIn = Field(EtiltIn,obj.pixel_size, obj.lambda, obj.unit);
                    Eout_scanned = obj.revPropagate(EtiltIn);
                    EscanInT(:,:,count) = EtiltIn;
                    Escan(:,:,count) = Eout_scanned.data;
                    count=count+1
                end
            end
            Escan = SizedArray(Escan, [obj.pixel_size,obj.pixel_size, obj.layer_thick], obj.unit);
            EscanInT = SizedArray(EscanInT, [obj.pixel_size,obj.pixel_size, obj.layer_thick], obj.unit);
        end
 
        function obj=finding_usp(obj)
            %DeltaX = 0;
            %DeltaY = 0;
            %Xp=linspace(-DeltaX*pi,DeltaX*pi,obj.DimSize);
            %Yp=linspace(-DeltaY*pi,DeltaY*pi,obj.DimSize);
            
            F = ones(obj.DimSize,obj.DimSize);
            %for i = 1:DimSize
            %    for j = 1:DimSize
            %        F(i,j)=Xp(i)+Yp(j);
            %    end
            %end
            
            Etilt=exp(1i*F);
            Etilt=Field(Etilt,obj.pixel_size, obj.lambda, obj.unit);
            Etilt.gpu_enabled = true;
            
            Etilt_out = Etilt.propagate(obj.medium,obj.Scat_Layer_No*obj.layer_thick,-1);
            %subplot(3,3,5);
            %imagesc(Etilt_out(:,:,Scat_Layer_No))
            
            FFT_Etout=fftshift(fft2(Etilt_out.data(:,:,1)));
            %subplot(3,3,6);
            figure;imagesc(abs(FFT_Etout))
            
            Pkb = abs(FFT_Etout((end)/2,:));
            
            
            L = obj.Scat_Layer_No*obj.layer_thick; %Thickness,µm%
            k0 = 2*pi/obj.lambda;
            
            N = obj.DimSize;
            dx = obj.pixel_size;
            x = (0:N-1)*dx;
            dk = 2*pi/(dx*N);
            k = ((0:N-1) - N/2)*dk;
            f = fit(k',Pkb','gauss1');
            c =  f.c1  ;
            
            ltr = ((k0^2)*L/(2*c^2))%mm
            sqrt(6*ltr/((k0^2)*L))
            obj.ltr = ltr;
        end
        
    end
    
    methods (Static)
        function Shaped_Field = PropagateASpiral(field_size,lambda,unit,Scat_Layer_No,scat,anisotrop,SpiralROI,Spiral)
            obj = VCAO(field_size,lambda,unit);
            obj = obj.CreateMedium(Scat_Layer_No,scat,anisotrop);
            obj = obj.CalcCoM(SpiralROI,Spiral);
            Shaped_Field=GetScattered(obj,1.5);
        end    
    end


end




 




% function RecoveryTest()
%     x=[-1024:1023];
%     Eround_in=exp((-x.^2-x'.^2)/512^2);
%     Erev_in= Field(Eround_in, pixel_size, lambda, 'um');
%     Erev_in.gpu_enabled = true;
%     Erev_out = Erev_in.propagate(SN,layer_thick*Scat_Layer_No,-1);
%     
%     
%     Erev_out = conj(Erev_out.data);
%     Erev_out= Field(Erev_out, pixel_size, lambda, 'um');
%     Erev_out.gpu_enabled = true;
%     Efw_out = Erev_out.propagate(SN,layer_thick*Scat_Layer_No,0);
% end
%%save('TL180104.mat','Shaped_Field','SN');
